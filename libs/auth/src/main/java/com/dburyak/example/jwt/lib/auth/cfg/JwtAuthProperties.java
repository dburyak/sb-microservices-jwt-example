package com.dburyak.example.jwt.lib.auth.cfg;

import io.jsonwebtoken.security.Keys;
import jakarta.annotation.Nullable;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Value;
import lombok.experimental.NonFinal;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.validator.constraints.time.DurationMin;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.bind.ConstructorBinding;
import org.springframework.boot.context.properties.bind.DefaultValue;
import org.springframework.validation.annotation.Validated;

import java.time.Duration;
import java.util.Map;
import java.util.Set;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.toMap;

@ConfigurationProperties(prefix = "auth.jwt")
@Validated
@Value
@NonFinal
public class JwtAuthProperties {

    /**
     * Whether to enable authentication using JWT tokens.
     */
    boolean enabled;

    /**
     * List of keys for verifying JWT tokens.
     * Has format <code>kid:alg:key, kid:alg:key, ...</code>.
     * Example: <code>kid1:HS256:secret1, kid2:HS256:secret2</code>.
     */
    Map<String, Key> keys;

    /**
     * List of trusted issuers. Any JWT tokens with other issuers will be rejected.
     */
    Set<String> trustedIssuers;

    /**
     * Allowed clock skew for verifying JWT tokens.
     */
    Duration allowedClockSkew;

    /**
     * JWT custom claim that contains the list of roles.
     */
    String rolesKey;

    /**
     * JWT custom claim that contains the tenant id.
     */
    String tenantIdKey;

    /**
     * JWT custom claim that contains the device id.
     */
    String deviceIdKey;

    /**
     * JWT token generation properties.
     */
    Generator generator;

    /**
     * Service token properties.
     */
    ServiceToken serviceToken;

    @ConstructorBinding
    public JwtAuthProperties(
            @DefaultValue("true") boolean enabled,
            @Nullable String keys,
            @DefaultValue("local.jwt.example.dburyak.com") @NotEmpty Set<String> trustedIssuers,
            @DefaultValue("30s") @NotNull Duration allowedClockSkew,
            @DefaultValue("r") @NotBlank String rolesKey,
            @DefaultValue("tid") @NotBlank String tenantIdKey,
            @DefaultValue("did") @NotBlank String deviceIdKey,
            @DefaultValue Generator generator,
            @DefaultValue ServiceToken serviceToken) {
        this.enabled = enabled;
        if (enabled) {
            if (StringUtils.isBlank(keys)) {
                throw new IllegalArgumentException("Keys must be set when JWT authentication is enabled");
            }
            this.keys = stream(keys.split("[\s,;]+"))
                    .map(JwtAuthProperties::parseKey)
                    .collect(toMap(
                            k -> k.kid,
                            k -> k
                    ));
        } else {
            this.keys = null;
        }
        this.trustedIssuers = trustedIssuers;
        this.allowedClockSkew = allowedClockSkew;
        this.rolesKey = rolesKey;
        this.tenantIdKey = tenantIdKey;
        this.deviceIdKey = deviceIdKey;
        this.generator = generator;
        this.serviceToken = serviceToken;
    }

    /**
     * JWT token generation properties.
     */
    @Value
    @NonFinal
    public static class Generator {

        /**
         * Whether the service needs to generate JWT tokens.
         */
        boolean enabled;

        /**
         * The key to use for signing JWT tokens in format <code>kid:alg:base64url(key)</code>.
         * Example: <code>a63fb07f:HS256:c29tZS1zZWNyZXQta2V5</code>.
         */
        Key key;

        /**
         * The issuer of the JWT tokens generated by this service.
         */
        String issuer;

        /**
         * Token expiration time.
         */
        Duration ttl;

        /**
         * Refresh token expiration time.
         */
        Duration refreshTokenTtl;

        @ConstructorBinding
        public Generator(
                @DefaultValue("false") boolean enabled,
                @Nullable String key,
                @DefaultValue("local.jwt.example.dburyak.com") @NotBlank String issuer,
                @DefaultValue("1h") @NotNull @DurationMin(seconds = 1) Duration ttl,
                @DefaultValue("30d") @NotNull @DurationMin(seconds = 1) Duration refreshTokenTtl) {
            this.enabled = enabled;
            if (enabled) {
                if (StringUtils.isBlank(key)) {
                    throw new IllegalArgumentException("Key must be set when JWT generation is enabled");
                }
                this.key = parseKey(key);
            } else {
                this.key = null;
            }
            this.issuer = issuer;
            this.ttl = ttl;
            if (refreshTokenTtl.compareTo(ttl) < 0) {
                throw new IllegalArgumentException("Refresh token TTL must be greater than token TTL");
            }
            this.refreshTokenTtl = refreshTokenTtl;
        }
    }

    @Value
    @NonFinal
    public static class ServiceToken {

        /**
         * Whether the service needs to generate JWT tokens.
         */
        boolean enabled;

        /**
         * The issuer of the JWT service tokens generated by this service. Allows overriding value from
         * {@link Generator#issuer}.
         */
        String issuer;

        @ConstructorBinding
        public ServiceToken(
                @DefaultValue("false") boolean enabled,
                @Nullable String issuer) {
            this.enabled = enabled;
            this.issuer = issuer;
        }
    }

    @Value
    public static class Key {
        String kid;
        String alg;
        String key;

        public java.security.Key toJdkKey() {
            if (alg.equals("HS256")) {
                return Keys.hmacShaKeyFor(key.getBytes(UTF_8));
            } else {
                throw new IllegalArgumentException("Unsupported algorithm: " + alg);
            }
        }
    }

    private static Key parseKey(String keyStr) {
        String[] parts = keyStr.split(":");
        if (parts.length != 3) {
            throw new IllegalArgumentException("Invalid key format: " + keyStr);
        }
        return new Key(parts[0], parts[1], parts[2]);
    }
}
